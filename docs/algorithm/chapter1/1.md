# 面试案例

## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串。

### 暴力解法 O(n^3)

```
for length -- O(n)
    for start ++ O(n)
        检测中间的子串是否是回文串 O(n)

```
```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  if (s == null) return null

  for (let length = s.length; length > 0; length--) {
    for (let start = 0; start + length <= s.length; start++) {
      const sub = s.substring(start, start + length)
      if (isPalindrome(sub)) {
        return sub
      }
    }
  }

  return ''
};
function isPalindrome (str) {
  let left = 0
  let right = str.length - 1
  
  while (left < right && str[left] === str[right]) {
    left++
    right--
  }
  return left >= right
}
```
:::tip
先想出暴力的方法，然后看一下暴力的方法中有什么是浪费的，然后把浪费的地方优化掉
:::
```
x|abcba|y
如果检测完bcb是回文串，那么在检测abcba 就不用全部检测，
同样的如果abcba是回文串，那么bcb也不用检测
```
### 基于中心点枚举法 Enumeration O(n^2)

```
背向双指针：

x|a|b|b|a|c
    ^ ^
    L R
  ^     ^
  L     R

L+1 ~ R-1

n   个奇数长度的回文串中心点
n-1 个偶数长度的回文串的中心点
```
#### 解题思路

由回文串正序和反序的性质相同，可以得出一个性质，如果一个字符串，其中心不是回文串，那么它一定不是个回文串。所以我们每次从中心开始，向两边延展首尾，判断是否是回文串。

#### 代码思路

1. 枚举中心 `center`，需要两个指针 `left`， `right`。
2. 如果 `s[left]` == `s[right]`，则 `left--`，`right++`，更新答案
3. 重复上一步，直到不相等就停止。
4. 注意：奇数和偶数长度的回文串是不同的，奇数中心是单独的一个字符，偶数的是相邻的两个字符。
```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  //  重点1：任何代码都要进行异常检测
  if (s == null) return null

  // 重点2：用空行区分开异常检测部分，核心代码部分，和返回值部分，属于高端代码风格技巧
  let longest = ''
  let sub = ''
  for (let middle = 0; middle < s.length; middle++) {
    // 重点3：子函数化避免重复代码
    // oddPalindorme
    sub = find_palindrome_from(s, middle, middle)
    // 重点4：通过返回值来避免使用全局变量这种不好的代码风格
    if (longest.length < sub.length) {
      longest = sub
    }

    // evenPalindorme
    sub = find_palindrome_from(s, middle, middle + 1)
    if (longest.length < sub.length) {
      longest = sub
    }
  }

  // 重点2：用空行区分开异常检测部分，核心代码部分，和返回值部分，属于高端代码风格技巧
  return longest
}

function find_palindrome_from(s, left, right) {
  while (left >= 0 && right <s.length) {
    // 重点5：将复杂判断拆分到 while 循环内部，而不是放在 while 循环中，提高代码可读性
    if (s[left] !== s[right]) {
      break
    }
    left--
    right++
  }

  return s.substring(left+1, right)
}
```